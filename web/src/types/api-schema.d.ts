/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register a new account */
        post: operations["register"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Login with passphrase and secret key */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Logout current session */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/2fa": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get 2FA status for current account */
        get: operations["twoFactorStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/2fa/setup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Start 2FA setup and return a TOTP secret */
        post: operations["setupTwoFactor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/2fa/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Enable 2FA by verifying a TOTP code */
        post: operations["enableTwoFactor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/2fa/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable 2FA
         * @description Disables TOTP two-factor authentication. Requires a valid TOTP code to confirm the action.
         */
        post: operations["disableTwoFactor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get WebAuthn/passkey status */
        get: operations["webauthnStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/register/begin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Begin WebAuthn credential registration
         * @description Starts a WebAuthn registration ceremony. Returns PublicKeyCredentialCreationOptions for the browser to pass to navigator.credentials.create().
         */
        post: operations["beginWebAuthnRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/register/finish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete WebAuthn credential registration
         * @description Completes the WebAuthn registration ceremony by verifying the browser's attestation response and storing the credential.
         */
        post: operations["finishWebAuthnRegistration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/login/begin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Begin WebAuthn login ceremony
         * @description Starts a WebAuthn login ceremony. Requires secret_key and passphrase in the body because the passphrase is needed for vault decryption after successful WebAuthn verification. Returns PublicKeyCredentialRequestOptions for the browser to pass to navigator.credentials.get().
         */
        post: operations["beginWebAuthnLogin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/login/finish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete WebAuthn login ceremony
         * @description Completes the WebAuthn login ceremony by verifying the browser's assertion response. On success, creates a full session (sets session and CSRF cookies).
         */
        post: operations["finishWebAuthnLogin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/credentials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List registered passkeys */
        get: operations["listPasskeys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/webauthn/credentials/{credentialID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Label a passkey */
        put: operations["labelPasskey"];
        post?: never;
        /** Delete a passkey */
        delete: operations["deletePasskey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/recovery-codes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get recovery codes status */
        get: operations["recoveryCodesStatus"];
        put?: never;
        /**
         * Generate new recovery codes
         * @description Generates a new set of one-time recovery codes. Any existing unused codes are replaced.
         */
        post: operations["generateRecoveryCodes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get authentication settings */
        get: operations["getAuthSettings"];
        /** Update authentication settings */
        put: operations["updateAuthSettings"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/step-up": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Step-up authentication via TOTP
         * @description Elevates the current session for sensitive operations by verifying a TOTP code. The step-up is valid for a limited time window.
         */
        post: operations["stepUpTOTP"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/step-up/passkey/begin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Begin step-up authentication via passkey
         * @description Starts a WebAuthn assertion ceremony for step-up authentication. Returns PublicKeyCredentialRequestOptions.
         */
        post: operations["beginStepUpPasskey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/step-up/passkey/finish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Complete step-up authentication via passkey */
        post: operations["finishStepUpPasskey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/invites/{token}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get invite information
         * @description Returns metadata about a pending invite (vault name, role, expiry). Used by the invitee before accepting.
         */
        get: operations["getInviteInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/invites/{token}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Accept a vault invite
         * @description Accepts a pending invite using the passphrase shared by the creator. The passphrase decrypts the credential blob (Argon2id + AES-256-GCM). Wrong passphrase = decryption failure = 403.
         */
        post: operations["acceptInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search items across all accessible vaults */
        get: operations["searchItems"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List vaults visible to authenticated member */
        get: operations["listVaults"];
        put?: never;
        /** Create a new vault */
        post: operations["createVault"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/open": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Open a vault */
        post: operations["openVault"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List items in a vault */
        get: operations["listItems"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current version numbers for all items in a vault
         * @description Returns a map of item_id to current version number, along with the vault epoch. Useful for detecting changes since the last sync.
         */
        get: operations["listItemVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items/{itemID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an item from a vault */
        get: operations["getItem"];
        /** Update an item in a vault */
        put: operations["updateItem"];
        /** Put an item into a vault */
        post: operations["putItem"];
        /** Delete an item from a vault */
        delete: operations["deleteItem"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items/{itemID}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List version history for an item */
        get: operations["getItemHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items/{itemID}/history/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get fields for a specific historical version of an item */
        get: operations["getHistoryVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/items/{itemID}/private-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the private key for a certificate item
         * @description Returns the full PEM-encoded private key for a certificate item. Requires owner access. The standard GetItem endpoint redacts the private_key field to "[REDACTED]" for security. This dedicated endpoint provides the real value and logs an audit event.
         */
        get: operations["getItemPrivateKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List vault audit log entries */
        get: operations["listAuditLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/audit/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export tamper-evident audit log
         * @description Returns all audit entries for the vault with their chain hashes and an HMAC-SHA256 signature for forensic integrity verification. Entries are ordered chronologically (oldest first) and linked via prev_hash to form a tamper-evident chain.
         */
        get: operations["exportAuditLog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List vault members */
        get: operations["listMembers"];
        put?: never;
        /** Add a member to a vault */
        post: operations["addMember"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/members/{memberID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Change a member's role */
        put: operations["changeMemberRole"];
        post?: never;
        /** Revoke a member from a vault */
        delete: operations["revokeMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a vault */
        delete: operations["deleteVault"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Export all vault items as an encrypted backup
         * @description Requires owner access. Decrypts all current items, serializes to JSON, and encrypts with the provided passphrase using Argon2id + AES-256-GCM. History is not exported. The response is a binary blob.
         */
        post: operations["exportVault"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/invites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List active invites for a vault */
        get: operations["listInvites"];
        put?: never;
        /**
         * Create a vault invite
         * @description Creates a pending invite for the vault. Returns a token and a one-time passphrase that must be shared with the invitee out-of-band. The passphrase is the Argon2id encryption key for the credential blob — it is NOT stored server-side.
         */
        post: operations["createInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/invites/{token}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Cancel a vault invite */
        delete: operations["cancelInvite"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initialize vault as a Certificate Authority
         * @description Creates a self-signed root CA (or intermediate CA) with the given subject. Generates an ECDSA P-256 CA key pair stored encrypted in the vault. Requires admin access.
         */
        post: operations["initCA"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get CA information
         * @description Returns CA metadata including subject, validity, serial counter, and certificate count.
         */
        get: operations["getCAInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/ca.pem": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download CA certificate
         * @description Returns the CA's X.509 certificate in PEM format.
         */
        get: operations["getCACert"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/issue": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Issue a new certificate
         * @description Issues a new X.509 certificate signed by the vault's CA. Generates a new ECDSA P-256 key pair. The certificate and private key are stored as a vault item. Requires admin access.
         */
        post: operations["issueCert"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/items/{itemID}/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revoke a certificate
         * @description Marks a certificate as revoked. The revocation is recorded for CRL generation. Requires admin access.
         */
        post: operations["revokeCert"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/items/{itemID}/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Renew a certificate
         * @description Revokes the existing certificate and issues a new one with the same subject and SANs. The new item links back to the old one via previous_item_id. Requires admin access.
         */
        post: operations["renewCert"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/crl.pem": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Generate and download Certificate Revocation List
         * @description Generates a CRL on demand from the vault's revocation list, signed by the CA. Returns the CRL in PEM format.
         */
        get: operations["getCRL"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/crl": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Regenerate and cache Certificate Revocation List
         * @description Regenerates the CRL from the vault's revocation list and caches it. Unlike the GET /crl.pem endpoint which returns the cached CRL, this endpoint forces regeneration. Requires admin access.
         */
        post: operations["generateCRL"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/pki/sign-csr": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sign a Certificate Signing Request
         * @description Signs a PEM-encoded PKCS#10 CSR with the vault's CA. The resulting certificate is stored as a vault item (without private key, since the requester keeps their own key). Requires admin access.
         */
        post: operations["signCSR"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vaults/{vaultID}/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import items from an encrypted backup into a vault
         * @description Accepts a multipart form with the encrypted backup file and passphrase. Each imported item receives a new ID. Duplicates are not detected.
         */
        post: operations["importVault"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        PaginationMeta: {
            /** @description Total number of items matching the query. */
            total_count?: number;
            /** @description Maximum items per page (server-capped at 200). */
            limit?: number;
            /** @description Number of items skipped. */
            offset?: number;
            /** @description Whether more items exist beyond this page. */
            has_more?: boolean;
        };
        CreateVaultRequest: {
            name?: string;
            description?: string;
        };
        CreateVaultResponse: {
            vault_id?: string;
            member_id?: string;
            /** Format: int64 */
            epoch?: number;
        };
        RegisterRequest: {
            /** @description Master passphrase (minimum 10 characters). */
            passphrase: string;
        };
        RegisterResponse: {
            secret_key?: string;
        };
        LoginRequest: {
            passphrase: string;
            secret_key: string;
            /** @description 6-digit TOTP code, required when 2FA is enabled. */
            totp_code?: string;
            /** @description One-time recovery code, accepted in place of totp_code when 2FA is enabled. */
            recovery_code?: string;
        };
        SetupTwoFactorResponse: {
            secret?: string;
            otpauth_url?: string;
            /** Format: date-time */
            expires_at?: string;
        };
        EnableTwoFactorRequest: {
            code: string;
        };
        TwoFactorStatusResponse: {
            enabled?: boolean;
        };
        WebAuthnStatusResponse: {
            enabled?: boolean;
            credential_count?: number;
        };
        WebAuthnLoginRequest: {
            secret_key: string;
            /** @description Passphrase for vault decryption after WebAuthn verification. */
            passphrase: string;
        };
        WebAuthnRegistrationResponse: {
            credential_id?: string;
        };
        ExportAuditEntryResponse: {
            id?: string;
            vault_id?: string;
            item_id?: string;
            action?: string;
            member_id?: string;
            /** Format: date-time */
            created_at?: string;
            /** @description SHA-256 hash linking this entry to its predecessor in the tamper-evident chain. */
            prev_hash?: string;
        };
        ExportAuditLogResponse: {
            vault_id?: string;
            entries?: components["schemas"]["ExportAuditEntryResponse"][];
            /** @description HMAC-SHA256 signature over all entries for forensic integrity verification. */
            signature?: string;
        };
        OpenVaultResponse: {
            vault_id?: string;
            member_id?: string;
            /** Format: int64 */
            epoch?: number;
        };
        VaultSummary: {
            vault_id?: string;
            name?: string;
            description?: string;
            /** Format: int64 */
            epoch?: number;
            item_count?: number;
        };
        ListVaultsResponse: components["schemas"]["PaginationMeta"] & {
            vaults?: components["schemas"]["VaultSummary"][];
        };
        ListItemsResponse: components["schemas"]["PaginationMeta"] & {
            items?: components["schemas"]["ItemSummary"][];
        };
        ItemSummary: {
            item_id?: string;
            name?: string;
            type?: string;
            /** Format: int64 */
            version?: number;
            /** Format: date-time */
            updated_at?: string;
            /** @description Subset of non-sensitive fields for display without opening the item. */
            preview?: {
                [key: string]: string;
            };
        };
        PutItemRequest: {
            /** @description Map of field name to value. Text fields are plain strings. Attachment fields use special prefixes: "_att.<filename>" for base64-encoded binary content (max 768 KiB decoded), "_attmeta.<filename>" for JSON metadata (content_type, size). Each attachment uses 2 fields toward the 64-field limit. */
            fields: {
                [key: string]: string;
            };
        };
        GetItemResponse: {
            item_id?: string;
            /** @description Map of field name to value. Text fields are plain strings. Attachment content fields ("_att.*") are base64-encoded. Sensitive fields such as `private_key` are returned as "[REDACTED]". Use the dedicated /private-key endpoint to retrieve the full value. */
            fields?: {
                [key: string]: string;
            };
        };
        UpdateItemRequest: {
            /** @description Map of field name to value. Text fields are plain strings. See PutItemRequest for attachment field conventions. */
            fields: {
                [key: string]: string;
            };
        };
        AddMemberRequest: {
            member_id: string;
            /** @description Base64 encoded 32-byte public key. */
            pub_key: string;
            /** @enum {string} */
            role: "owner" | "writer" | "reader";
        };
        AddMemberResponse: {
            /** Format: int64 */
            epoch?: number;
        };
        HistoryEntryResponse: {
            /** Format: int64 */
            version?: number;
            /** Format: date-time */
            updated_at?: string;
            updated_by?: string;
        };
        GetItemHistoryResponse: {
            item_id?: string;
            history?: components["schemas"]["HistoryEntryResponse"][];
        };
        GetHistoryVersionResponse: {
            item_id?: string;
            /** Format: int64 */
            version?: number;
            /** @description Map of field name to value at this version. Text fields are plain strings. Attachment content fields ("_att.*") are base64-encoded. */
            fields?: {
                [key: string]: string;
            };
        };
        AuditEntryResponse: {
            id?: string;
            item_id?: string;
            /** @enum {string} */
            action?: "item_accessed" | "item_created" | "item_updated" | "item_deleted" | "vault_exported" | "vault_imported" | "ca_initialized" | "cert_issued" | "cert_revoked" | "cert_renewed" | "crl_generated" | "csr_signed" | "private_key_accessed" | "webauthn_registered" | "webauthn_login_success";
            member_id?: string;
            /** Format: date-time */
            created_at?: string;
        };
        ListAuditLogsResponse: components["schemas"]["PaginationMeta"] & {
            entries?: components["schemas"]["AuditEntryResponse"][];
        };
        ErrorResponse: {
            error?: string;
            /** @description Request correlation ID for support and debugging. */
            correlation_id?: string;
        };
        ExportVaultRequest: {
            /** @description Passphrase to encrypt the backup file. Must not be empty. */
            passphrase: string;
        };
        ImportVaultResponse: {
            /** @description Number of items successfully imported. */
            imported_count?: number;
        };
        InitCARequest: {
            common_name: string;
            organization?: string;
            org_unit?: string;
            country?: string;
            province?: string;
            locality?: string;
            /** @description CA certificate validity in years (default 10). */
            validity_years?: number;
            /** @description Whether this is an intermediate CA (default false = root CA). */
            is_intermediate?: boolean;
        };
        InitCAResponse: {
            subject?: string;
        };
        CAInfoResponse: {
            is_ca?: boolean;
            is_intermediate?: boolean;
            subject?: string;
            /** Format: date-time */
            not_before?: string;
            /** Format: date-time */
            not_after?: string;
            /** Format: int64 */
            next_serial?: number;
            /** Format: int64 */
            crl_number?: number;
            cert_count?: number;
        };
        IssueCertRequest: {
            common_name: string;
            organization?: string;
            org_unit?: string;
            country?: string;
            /** @description Certificate validity in days (default 365). */
            validity_days?: number;
            /** @description Key usage flags. Values: digital_signature, key_encipherment, data_encipherment, content_commitment. */
            key_usages?: string[];
            /** @description Extended key usage values. Values: server_auth, client_auth, code_signing, email_protection. */
            ext_key_usages?: string[];
            dns_names?: string[];
            ip_addresses?: string[];
            email_addresses?: string[];
        };
        IssueCertResponse: {
            item_id?: string;
            serial_number?: string;
            subject?: string;
            /** Format: date-time */
            not_before?: string;
            /** Format: date-time */
            not_after?: string;
        };
        RevokeCertRequest: {
            /** @description Revocation reason. Values: unspecified, key_compromise, ca_compromise, affiliation_changed, superseded, cessation_of_operation. */
            reason?: string;
        };
        RenewCertRequest: {
            /** @description New certificate validity in days (default 365). */
            validity_days?: number;
        };
        RenewCertResponse: {
            new_item_id?: string;
            old_item_id?: string;
            serial_number?: string;
        };
        SignCSRRequest: {
            /** @description PEM-encoded PKCS#10 certificate signing request. */
            csr: string;
            /** @description Certificate validity in days (default 365). */
            validity_days?: number;
            ext_key_usages?: string[];
        };
        SignCSRResponse: {
            item_id?: string;
            serial_number?: string;
            /** @description PEM-encoded signed certificate. */
            certificate?: string;
        };
        DisableTwoFactorRequest: {
            /** @description Valid TOTP code to confirm 2FA disable. */
            code: string;
        };
        AuthSettingsResponse: {
            /**
             * @description WebAuthn/passkey login policy.
             * @enum {string}
             */
            passkey_policy?: "allowed" | "required" | "disabled";
            totp_enabled?: boolean;
        };
        UpdateAuthSettingsRequest: {
            /** @enum {string} */
            passkey_policy: "allowed" | "required" | "disabled";
        };
        StepUpTOTPRequest: {
            /** @description 6-digit TOTP code for step-up verification. */
            code: string;
        };
        StepUpResponse: {
            verified?: boolean;
            /** @description Method used for step-up (totp or passkey). */
            method?: string;
            /** Format: date-time */
            expires_at?: string;
        };
        StepUpRequiredResponse: {
            error?: string;
            /** @description Available step-up methods (e.g. ["totp", "passkey"]). */
            methods?: string[];
        };
        MutationResponse: {
            item_id?: string;
            /** Format: int64 */
            version?: number;
        };
        ItemVersionsResponse: {
            /** @description Map of item_id to current version number. */
            versions?: {
                [key: string]: number;
            };
            /** Format: int64 */
            epoch?: number;
        };
        MemberSummary: {
            member_id?: string;
            /** @enum {string} */
            role?: "owner" | "writer" | "reader";
            status?: string;
            /** Format: int64 */
            added_epoch?: number;
        };
        ListMembersResponse: {
            members?: components["schemas"]["MemberSummary"][];
        };
        ChangeMemberRoleRequest: {
            /** @enum {string} */
            role: "owner" | "writer" | "reader";
        };
        CreateInviteRequest: {
            /** @enum {string} */
            role: "owner" | "writer" | "reader";
        };
        CreateInviteResponse: {
            token?: string;
            /** @description One-time passphrase for the invitee. Must be shared out-of-band. The server does NOT store this — it is used as the Argon2id encryption key for the credential blob. */
            passphrase?: string;
            /** Format: date-time */
            expires_at?: string;
            /** @description Full URL the invitee can visit to accept. */
            invite_url?: string;
        };
        InviteSummary: {
            token?: string;
            /** @enum {string} */
            role?: "owner" | "writer" | "reader";
            /** Format: date-time */
            expires_at?: string;
        };
        ListInvitesResponse: {
            invites?: components["schemas"]["InviteSummary"][];
        };
        InviteInfoResponse: {
            vault_name?: string;
            /** @enum {string} */
            role?: "owner" | "writer" | "reader";
            /** Format: date-time */
            expires_at?: string;
            creator_id?: string;
        };
        AcceptInviteRequest: {
            /** @description Invite passphrase shared by the creator. */
            passphrase: string;
        };
        AcceptInviteResponse: {
            vault_id?: string;
            member_id?: string;
        };
        PasskeySummary: {
            credential_id?: string;
            label?: string;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            last_used_at?: string;
            backup_state?: boolean;
        };
        ListPasskeysResponse: {
            passkeys?: components["schemas"]["PasskeySummary"][];
        };
        LabelPasskeyRequest: {
            label: string;
        };
        RecoveryCodesStatusResponse: {
            has_codes?: boolean;
            codes_total?: number;
            codes_unused?: number;
        };
        GenerateRecoveryCodesResponse: {
            /** @description One-time recovery codes. Store securely — they cannot be viewed again. */
            codes?: string[];
        };
        SearchResultItem: {
            vault_id?: string;
            vault_name?: string;
            item_id?: string;
            name?: string;
            type?: string;
            matched_field?: string;
        };
        SearchResponse: components["schemas"]["PaginationMeta"] & {
            results?: components["schemas"]["SearchResultItem"][];
        };
    };
    responses: never;
    parameters: {
        /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
        CSRFToken: string;
        /** @description Maximum number of items to return (default 100, max 200). */
        PaginationLimit: number;
        /** @description Number of items to skip for pagination. */
        PaginationOffset: number;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    register: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterRequest"];
            };
        };
        responses: {
            /** @description Account created. Sets `ironhand_session` (SameSite=Lax) and `ironhand_session_key` (SameSite=Strict) cookies. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RegisterResponse"];
                };
            };
            /** @description Invalid request (e.g. passphrase too short) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginRequest"];
            };
        };
        responses: {
            /** @description Logged in. Sets `ironhand_session` (SameSite=Lax) and `ironhand_session_key` (SameSite=Strict) cookies. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid credentials */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many failed login attempts */
            429: {
                headers: {
                    /** @description Seconds to wait before retrying */
                    "Retry-After"?: number;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Logged out */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    twoFactorStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description 2FA status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TwoFactorStatusResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    setupTwoFactor: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description 2FA setup initialized */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetupTwoFactorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    enableTwoFactor: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnableTwoFactorRequest"];
            };
        };
        responses: {
            /** @description 2FA enabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TwoFactorStatusResponse"];
                };
            };
            /** @description Setup expired or invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid one-time code or unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    disableTwoFactor: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DisableTwoFactorRequest"];
            };
        };
        responses: {
            /** @description 2FA disabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TwoFactorStatusResponse"];
                };
            };
            /** @description Invalid or missing TOTP code */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    webauthnStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebAuthn status and credential count */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebAuthnStatusResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    beginWebAuthnRegistration: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Credential creation options */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebAuthn not configured on server */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    finishWebAuthnRegistration: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Credential registered */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebAuthnRegistrationResponse"];
                };
            };
            /** @description Registration failed or ceremony expired */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebAuthn not configured on server */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    beginWebAuthnLogin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebAuthnLoginRequest"];
            };
        };
        responses: {
            /** @description Credential request options */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No WebAuthn credentials registered */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebAuthn not configured on server */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many failed login attempts */
            429: {
                headers: {
                    /** @description Seconds to wait before retrying */
                    "Retry-After"?: number;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    finishWebAuthnLogin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Login successful. Sets `ironhand_session` (SameSite=Lax) and `ironhand_session_key` (SameSite=Strict) cookies. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Ceremony expired or invalid response */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebAuthn verification failed or invalid passphrase */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebAuthn not configured on server */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listPasskeys: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Passkey list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListPasskeysResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    labelPasskey: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                credentialID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LabelPasskeyRequest"];
            };
        };
        responses: {
            /** @description Label updated */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Credential not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deletePasskey: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                credentialID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Passkey deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Credential not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    recoveryCodesStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Recovery codes status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecoveryCodesStatusResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    generateRecoveryCodes: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description New recovery codes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateRecoveryCodesResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAuthSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Current auth settings */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthSettingsResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateAuthSettings: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateAuthSettingsRequest"];
            };
        };
        responses: {
            /** @description Settings updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthSettingsResponse"];
                };
            };
            /** @description Invalid policy value */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stepUpTOTP: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StepUpTOTPRequest"];
            };
        };
        responses: {
            /** @description Step-up verified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StepUpResponse"];
                };
            };
            /** @description Invalid TOTP code or unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    beginStepUpPasskey: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Credential request options */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No passkeys registered */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    finishStepUpPasskey: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Step-up verified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StepUpResponse"];
                };
            };
            /** @description Ceremony expired or invalid response */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInviteInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                token: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Invite details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InviteInfoResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invite not found or expired */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    acceptInvite: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                token: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AcceptInviteRequest"];
            };
        };
        responses: {
            /** @description Invite accepted, vault membership granted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AcceptInviteResponse"];
                };
            };
            /** @description Missing passphrase */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Wrong passphrase (decryption failed) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invite not found or expired */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    searchItems: {
        parameters: {
            query: {
                /** @description Search query string. */
                q: string;
                /** @description Maximum number of items to return (default 100, max 200). */
                limit?: components["parameters"]["PaginationLimit"];
                /** @description Number of items to skip for pagination. */
                offset?: components["parameters"]["PaginationOffset"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Search results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Missing or empty query */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listVaults: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return (default 100, max 200). */
                limit?: components["parameters"]["PaginationLimit"];
                /** @description Number of items to skip for pagination. */
                offset?: components["parameters"]["PaginationOffset"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Vault list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListVaultsResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createVault: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateVaultRequest"];
            };
        };
        responses: {
            /** @description Vault created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateVaultResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    openVault: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Vault opened successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenVaultResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listItems: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return (default 100, max 200). */
                limit?: components["parameters"]["PaginationLimit"];
                /** @description Number of items to skip for pagination. */
                offset?: components["parameters"]["PaginationOffset"];
            };
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of item IDs */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListItemsResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listItemVersions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Item version manifest */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemVersionsResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getItem: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Item data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetItemResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateItem: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateItemRequest"];
            };
        };
        responses: {
            /** @description Item updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putItem: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PutItemRequest"];
            };
        };
        responses: {
            /** @description Item stored successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteItem: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Item deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getItemHistory: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Version history */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetItemHistoryResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getHistoryVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
                version: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Historical version fields */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetHistoryVersionResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getItemPrivateKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Private key PEM */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/x-pem-file": string;
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden (not owner) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Item not found or has no private key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listAuditLogs: {
        parameters: {
            query?: {
                item_id?: string;
                /** @description Maximum number of items to return (default 100, max 200). */
                limit?: components["parameters"]["PaginationLimit"];
                /** @description Number of items to skip for pagination. */
                offset?: components["parameters"]["PaginationOffset"];
            };
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Audit log entries (newest first) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListAuditLogsResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    exportAuditLog: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Audit log with chain integrity data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportAuditLogResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listMembers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Member list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListMembersResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    addMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddMemberRequest"];
            };
        };
        responses: {
            /** @description Member added successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AddMemberResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    changeMemberRole: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                vaultID: string;
                memberID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChangeMemberRoleRequest"];
            };
        };
        responses: {
            /** @description Role updated */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden (only owner can change roles) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Member not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    revokeMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                memberID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Member revoked successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AddMemberResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteVault: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Vault deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    exportVault: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportVaultRequest"];
            };
        };
        responses: {
            /** @description Encrypted backup file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description Invalid request (e.g. empty passphrase) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden (not owner) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listInvites: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Active invites */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListInvitesResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createInvite: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateInviteRequest"];
            };
        };
        responses: {
            /** @description Invite created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateInviteResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden (insufficient role) */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cancelInvite: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                vaultID: string;
                token: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Invite cancelled */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Only the invite creator can cancel */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invite not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    initCA: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["InitCARequest"];
            };
        };
        responses: {
            /** @description CA initialized */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InitCAResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault is already a CA */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getCAInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description CA information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CAInfoResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault is not a CA */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCACert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description CA certificate PEM */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault is not a CA */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    issueCert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IssueCertRequest"];
            };
        };
        responses: {
            /** @description Certificate issued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IssueCertResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    revokeCert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RevokeCertRequest"];
            };
        };
        responses: {
            /** @description Certificate revoked */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Certificate not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Certificate already revoked */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    renewCert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
                itemID: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RenewCertRequest"];
            };
        };
        responses: {
            /** @description Certificate renewed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RenewCertResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Certificate not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCRL: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description CRL in PEM format */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/x-pem-file": string;
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault is not a CA */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    generateCRL: {
        parameters: {
            query?: never;
            header: {
                /** @description CSRF double-submit token. Must match the value of the `ironhand_csrf` cookie. Required on all mutating (POST/PUT/DELETE) requests that use cookie-based session authentication. GET/HEAD/OPTIONS requests and header-authenticated requests are exempt. */
                "X-CSRF-Token": components["parameters"]["CSRFToken"];
            };
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description CRL regenerated (PEM format) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/x-pem-file": string;
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Vault is not a CA */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    signCSR: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignCSRRequest"];
            };
        };
        responses: {
            /** @description CSR signed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SignCSRResponse"];
                };
            };
            /** @description Invalid CSR */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    importVault: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vaultID: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description The .ironhand-backup file.
                     */
                    file: string;
                    /** @description Passphrase used to encrypt the backup. */
                    passphrase: string;
                };
            };
        };
        responses: {
            /** @description Items imported successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImportVaultResponse"];
                };
            };
            /** @description Invalid request, wrong passphrase, or corrupt file */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
